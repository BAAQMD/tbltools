% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scale_at.R
\name{scale_at}
\alias{scale_at}
\alias{multiply_at}
\alias{divide_at}
\title{Rescale columns of tabular data}
\usage{
multiply_at(...)

divide_at(...)
}
\arguments{
\item{.tbl}{tabular data}

\item{.vars}{A list of columns generated by \code{vars()}, a character vector of
column names, a numeric vector of column positions, or \code{NULL}.}

\item{by}{a value or expression, to be evaluated within \code{.tbl}}
}
\description{
\code{multiply_at()} and \code{divide_at()} avoid one of the pitfalls of
\code{mutate_at()}, which is that \code{mutate_at()} applies transformations
sequentially, rather than in parallel. See Details, below.
}
\details{
Suppose we want to "normalize" all columns by the values in one
column. The following code doesn't yield that result:

\code{mtcars \%>\% mutate_at(vars(everything()), ~ 1 / wt)}

All columns after \code{wt} are left "untouched". Why?

What's happening is that the columns are being transformed sequentially,
rather than in parallel. First \code{mpg} is divided by \code{wt}. Then, \code{cyl} is
divided by \code{wt}, followed by \code{disp}, \code{hp}, and \code{drat}.

Next, \code{wt} is divided by \code{wt}. From this point on, \code{wt} is equal to 1.

When the next column, \code{qsec}, is divided by \code{wt}, it's just being divided
by 1. And so on for \code{vs}, \code{am}, \code{gear}, and \code{carb}. The values in those
columns remain the same.
}
\section{Functions}{
\itemize{
\item \code{multiply_at}: multiplication

\item \code{divide_at}: division
}}

\examples{
mtcars \%>\% multiply_at(vars(everything), 2)  # double every value
mtcars \%>\% divide_at(vars(mpg, cyl), mpg)    # divide `mpg` and `cyl` by `mpg`

}
