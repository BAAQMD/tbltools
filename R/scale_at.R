#' Rescale columns of tabular data
#'
#' @description Rescale columns (of tabular data) by some value or expression.
#'
#'   `multiply_at()` and `divide_at()` avoid one of the pitfalls of
#'   `mutate_at()`, which is that `mutate_at()` applies transformations
#'   sequentially, rather than in parallel. See Details, below.
#'
#' @details Suppose we want to "normalize" all columns by the values in one
#'   column. The following code doesn't yield that result:
#'
#'   `mtcars %>% mutate_at(vars(everything()), ~ 1 / wt)`
#'
#'   All columns after `wt` are left "untouched". Why?
#'
#'   What's happening is that the columns are being transformed sequentially,
#'   rather than in parallel. First `mpg` is divided by `wt`. Then, `cyl` is
#'   divided by `wt`, followed by `disp`, `hp`, and `drat`.
#'
#'   Next, `wt` is divided by `wt`. From this point on, `wt` is equal to 1.
#'
#'   When the next column, `qsec`, is divided by `wt`, it's just being divided
#'   by 1. And so on for `vs`, `am`, `gear`, and `carb`. The values in those
#'   columns remain the same.
#'
#' @param .tbl tabular data
#' @param .vars A list of columns generated by `vars()`, a character vector of
#'   column names, a numeric vector of column positions, or `NULL`.
#' @param by a value or expression, to be evaluated within `.tbl`
#'
#' @examples
#' mtcars %>% multiply_at(vars(everything), 2)  # doubles every value
#'
NULL

#' @export
scale_at <- function (
  .tbl,
  .vars,
  by,
  operator,
  ...,
  .cols = NULL,
  verbose = getOption("verbose")
) {

  msg <- function (...) if(isTRUE(verbose)) message("[multiply_at] ", ...)

  if (isTRUE(verbose)) {
    glimpse(.tbl)
  }

  # Capture for non-standard evaluation
  .by <- enquo(by)

  # Random string to use as a temporary column within `.tbl`
  tmpvar <- "foo" # digest::digest(rnorm(1))

  # Create temporary column
  mutated <-
    mutate(
      .tbl,
      !!tmpvar := !!.by)

  if (isTRUE(verbose)) {
    glimpse(mutated)
  }

  # Scale `.vars` by temporary column
  multiplied <-
    mutate_at(
      mutated,
      .vars,
      .funs = ~ operator(., get(tmpvar)),
      ...,
      .cols = .cols)

  # Drop temporary column
  tidied <-
    select(
      multiplied,
      -matches(tmpvar))

  return(tidied)

}

multiply_at <-
  purrr::partial(
    scale_at,
    operator = `*`)
